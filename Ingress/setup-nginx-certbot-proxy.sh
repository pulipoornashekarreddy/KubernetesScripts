#!/usr/bin/env bash

# file name setup_nginx_and_certificates.sh
# rm -rf setup_nginx_and_certificates.sh
# sudo nano setup_nginx_and_certificates.sh
# sudo bash setup_nginx_and_certificates.sh

set -euo pipefail

# -------------------------
# CONFIG (edit these)
# -------------------------
EMAIL="admin@cleanerp.com"              # certbot email (for Let's Encrypt)
NAMESPACE="ingress-nginx"               # ingress controller namespace
SERVICE_NAME="ingress-nginx-controller" # ingress controller service name
WEBROOT_DIR="/var/www/letsencrypt"      # path used for HTTP-01 challenges
NGINX_CONF="/etc/nginx/sites-available/cleanerp.conf"
NGINX_CONF_LINK="/etc/nginx/sites-enabled/cleanerp.conf"

# Domains to configure (space-separated)
DOMAINS=(
  "profile.cleanerp.com"
  "test-profile.cleanerp.com"
  "identity.cleanerp.com"
  "test-identity.cleanerp.com"
  "academic.cleanerp.com"
  "test-academic.cleanerp.com"
  "www.cleanerp.com"
  "cleanerp.com"
  "test.cleanerp.com"
  "test-metrics.cleanerp.com"
  "metrics.cleanerp.com"
  "assessment.cleanerp.com"
  "test-assessment.cleanerp.com"
  # add more if required
)

sudo mkdir -p /root/.kube
sudo cp /etc/kubernetes/admin.conf /root/.kube/config
sudo chown root:root /root/.kube/config
sudo chmod 600 /root/.kube/config


# -------------------------
# Helper & checks
# -------------------------
echo; echo "== Bootstrap OVH host reverse-proxy -> Kubernetes NodePort ingress =="
echo "This script will patch the ingress svc to NodePort, install nginx/certbot (apt),"
echo "generate nginx proxy config, obtain certs via certbot (webroot) and enable auto-renewal."
echo

# Check kubectl
if ! command -v kubectl >/dev/null 2>&1; then
  echo "ERROR: kubectl not found. Install and configure kubectl before running this script."
  exit 1
fi

# Ensure script runs with sudo/root for system changes
if [ "$(id -u)" -ne 0 ]; then
  echo "This script requires sudo/root. Re-run with sudo."
  exit 1
fi

# -------------------------
# Install nginx & certbot
# -------------------------
echo; echo "1) Installing nginx and certbot (if missing)..."
apt update -y

if ! dpkg -s nginx >/dev/null 2>&1; then
  apt install -y nginx
  echo "nginx installed."
else
  echo "nginx already installed."
fi

if ! command -v certbot >/dev/null 2>&1; then
  apt install -y certbot
  echo "certbot installed."
else
  echo "certbot already installed."
fi

# ensure sites-available/ sites-enabled structure
mkdir -p /etc/nginx/sites-available
mkdir -p /etc/nginx/sites-enabled

# create webroot for ACME http-01
mkdir -p "${WEBROOT_DIR}"
chown www-data:www-data "${WEBROOT_DIR}"
chmod 755 "${WEBROOT_DIR}"

# -------------------------
# Patch ingress svc -> NodePort
# -------------------------
echo; echo "2) Patching ingress-nginx service to NodePort (if not already)..."
SVC_TYPE=$(kubectl get svc "${SERVICE_NAME}" -n "${NAMESPACE}" -o jsonpath='{.spec.type}' 2>/dev/null || echo "NotFound")
if [ "${SVC_TYPE}" != "NodePort" ]; then
  kubectl patch svc "${SERVICE_NAME}" -n "${NAMESPACE}" \
    -p '{"spec": {"type": "NodePort"}}'
  echo "Patched ${NAMESPACE}/${SERVICE_NAME} to type=NodePort"
else
  echo "Service already NodePort."
fi

echo; echo "Waiting a few seconds for svc to update..."
sleep 5

# -------------------------
# Discover NodePort numbers
# -------------------------
echo; echo "3) Discover NodePort numbers used by ingress controller..."
HTTP_NODEPORT=$(kubectl get svc "${SERVICE_NAME}" -n "${NAMESPACE}" -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null || true)
HTTPS_NODEPORT=$(kubectl get svc "${SERVICE_NAME}" -n "${NAMESPACE}" -o jsonpath='{.spec.ports[?(@.port==443)].nodePort}' 2>/dev/null || true)

if [ -z "$HTTP_NODEPORT" ] || [ -z "$HTTPS_NODEPORT" ]; then
  echo "ERROR: Could not discover NodePort values for ports 80/443. Current svc:"
  kubectl -n "${NAMESPACE}" get svc "${SERVICE_NAME}" -o yaml
  exit 1
fi

echo "Found HTTP NodePort:  $HTTP_NODEPORT"
echo "Found HTTPS NodePort: $HTTPS_NODEPORT"

# -------------------------
# Generate initial HTTP nginx config (serves ACME webroot + proxies)
# -------------------------
echo; echo "4) Generating temporary nginx HTTP config (serves ACME webroot + proxy to NodePort)..."

cat > "${NGINX_CONF}" <<EOF
# Auto-generated by bootstrap-ovh-ingress-proxy.sh
# Temporary HTTP config: serves .well-known from ${WEBROOT_DIR} and proxies to ingress NodePort
EOF

for D in "${DOMAINS[@]}"; do
  cat >> "${NGINX_CONF}" <<EOF

server {
    listen 80;
    server_name ${D};

    # serve ACME challenge
    location /.well-known/acme-challenge/ {
        root ${WEBROOT_DIR};
        try_files \$uri =404;
    }

    # proxy all other traffic to the ingress controller NodePort (HTTP)
    location / {
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_pass http://127.0.0.1:${HTTP_NODEPORT};
    }
}
EOF
done

# enable config
ln -sf "${NGINX_CONF}" "${NGINX_CONF_LINK}"

# Test and reload nginx
nginx -t
systemctl reload nginx

# -------------------------
# Obtain certificates with certbot (webroot)
# -------------------------
echo; echo "5) Running certbot (webroot) for each domain..."
for D in "${DOMAINS[@]}"; do
  echo; echo "-> Requesting certificate for ${D}"
  # certbot will fail if DNS not pointed correctly; run but continue to next domain on failure
  set +e
  certbot certonly --webroot -w "${WEBROOT_DIR}" -d "${D}" --agree-tos --email "${EMAIL}" --non-interactive --quiet
  RES=$?
  set -e
  if [ $RES -ne 0 ]; then
    echo "WARNING: certbot failed for ${D} (maybe DNS not pointed). Continue to next domain."
  else
    echo "Certificate obtained for ${D}"
  fi
done

# -------------------------
# Generate final HTTPS nginx config (redirect HTTP -> HTTPS)
# -------------------------
echo; echo "6) Generating final HTTPS nginx config (if certs exist)..."

cat > "${NGINX_CONF}" <<EOF
# Auto-generated by bootstrap-ovh-ingress-proxy.sh
# Final HTTPS config: redirect HTTP -> HTTPS and proxy to NodePort
EOF

for D in "${DOMAINS[@]}"; do
  # check cert path
  if [ -f "/etc/letsencrypt/live/${D}/fullchain.pem" ]; then
    echo "Adding HTTPS block for ${D} (certificate found)."
    cat >> "${NGINX_CONF}" <<EOF

server {
    listen 80;
    server_name ${D};
    return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl;
    server_name ${D};

    ssl_certificate     /etc/letsencrypt/live/${D}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${D}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;

    location / {
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_pass http://127.0.0.1:${HTTP_NODEPORT};
    }
}
EOF
  else
    echo "No certificate found for ${D}. Leaving HTTP only entry for it (ACME may still be pending)."
    cat >> "${NGINX_CONF}" <<EOF

server {
    listen 80;
    server_name ${D};

    location /.well-known/acme-challenge/ {
        root ${WEBROOT_DIR};
        try_files \$uri =404;
    }

    location / {
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_pass http://127.0.0.1:${HTTP_NODEPORT};
    }
}
EOF
  fi
done

# finalize and reload nginx
nginx -t
systemctl reload nginx

# -------------------------
# Create a cronjob for cert renewal (2 months check)
# -------------------------
echo; echo "7) Ensuring certbot renewal cron exists..."
CRONENTRY="0 3 1 */2 * /usr/bin/certbot renew --quiet --deploy-hook 'systemctl reload nginx'"

cat > /etc/cron.d/certbot-renew <<EOF
# Renew Let's Encrypt certificates every 60 days at 03:00 AM
${CRONENTRY}
EOF

chmod 644 /etc/cron.d/certbot-renew

echo
echo "== Completed =="
echo " - NodePort HTTP: ${HTTP_NODEPORT}"
echo " - NodePort HTTPS: ${HTTPS_NODEPORT}"
echo " - NGINX config: ${NGINX_CONF}"
echo " - Webroot for ACME: ${WEBROOT_DIR}"
echo
echo "IMPORTANT: Make sure the DNS A records for your domains point to this server's public IP."
echo "If certbot failed for any domain, fix DNS and re-run this script or run:"
echo "  certbot certonly --webroot -w ${WEBROOT_DIR} -d your.domain"
echo
echo "You may also want to remove cert-manager from the cluster if you will handle TLS at the host."
